{"ast":null,"code":"import { parser, DocumentType, ApolloConsumer } from '@apollo/react-common';\nexport { ApolloConsumer, ApolloProvider, getApolloContext, resetApolloContext } from '@apollo/react-common';\nimport { __extends, __assign, __rest } from 'tslib';\nimport React from 'react';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport { Query, Mutation, Subscription } from '@apollo/react-components';\nimport { invariant } from 'ts-invariant';\n\nvar defaultMapPropsToOptions = function () {\n  return {};\n};\n\nvar defaultMapPropsToSkip = function () {\n  return false;\n};\n\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nfunction calculateVariablesFromProps(operation, props) {\n  var variables = {};\n\n  for (var _i = 0, _a = operation.variables; _i < _a.length; _i++) {\n    var _b = _a[_i],\n        variable = _b.variable,\n        type = _b.type;\n    if (!variable.name || !variable.name.value) continue;\n    var variableName = variable.name.value;\n    var variableProp = props[variableName];\n\n    if (typeof variableProp !== 'undefined') {\n      variables[variableName] = variableProp;\n      continue;\n    }\n\n    if (type.kind !== 'NonNullType') {\n      variables[variableName] = undefined;\n    }\n  }\n\n  return variables;\n}\n\nvar GraphQLBase = function (_super) {\n  __extends(GraphQLBase, _super);\n\n  function GraphQLBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.withRef = false;\n    _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);\n    return _this;\n  }\n\n  GraphQLBase.prototype.getWrappedInstance = function () {\n    process.env.NODE_ENV === \"production\" ? invariant(this.withRef, 2) : invariant(this.withRef, \"To access the wrapped instance, you need to specify \" + \"{ withRef: true } in the options\");\n    return this.wrappedInstance;\n  };\n\n  GraphQLBase.prototype.setWrappedInstance = function (ref) {\n    this.wrappedInstance = ref;\n  };\n\n  return GraphQLBase;\n}(React.Component);\n\nfunction withQuery(document, operationOptions) {\n  if (operationOptions === void 0) {\n    operationOptions = {};\n  }\n\n  var operation = parser(document);\n  var _a = operationOptions.options,\n      options = _a === void 0 ? defaultMapPropsToOptions : _a,\n      _b = operationOptions.skip,\n      skip = _b === void 0 ? defaultMapPropsToSkip : _b,\n      _c = operationOptions.alias,\n      alias = _c === void 0 ? 'Apollo' : _c;\n  var mapPropsToOptions = options;\n\n  if (typeof mapPropsToOptions !== 'function') {\n    mapPropsToOptions = function () {\n      return options;\n    };\n  }\n\n  var mapPropsToSkip = skip;\n\n  if (typeof mapPropsToSkip !== 'function') {\n    mapPropsToSkip = function () {\n      return skip;\n    };\n  }\n\n  var lastResultProps;\n  return function (WrappedComponent) {\n    var graphQLDisplayName = alias + \"(\" + getDisplayName(WrappedComponent) + \")\";\n\n    var GraphQL = function (_super) {\n      __extends(GraphQL, _super);\n\n      function GraphQL() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      GraphQL.prototype.render = function () {\n        var _this = this;\n\n        var props = this.props;\n        var shouldSkip = mapPropsToSkip(props);\n        var opts = shouldSkip ? Object.create(null) : __assign({}, mapPropsToOptions(props));\n\n        if (!shouldSkip && !opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(operation, props);\n        }\n\n        return React.createElement(Query, __assign({}, opts, {\n          displayName: graphQLDisplayName,\n          skip: shouldSkip,\n          query: document\n        }), function (_a) {\n          var _b, _c;\n\n          var _ = _a.client,\n              data = _a.data,\n              r = __rest(_a, [\"client\", \"data\"]);\n\n          if (operationOptions.withRef) {\n            _this.withRef = true;\n            props = Object.assign({}, props, {\n              ref: _this.setWrappedInstance\n            });\n          }\n\n          if (shouldSkip) {\n            return React.createElement(WrappedComponent, __assign({}, props, {}));\n          }\n\n          var result = Object.assign(r, data || {});\n          var name = operationOptions.name || 'data';\n          var childProps = (_b = {}, _b[name] = result, _b);\n\n          if (operationOptions.props) {\n            var newResult = (_c = {}, _c[name] = result, _c.ownProps = props, _c);\n            lastResultProps = operationOptions.props(newResult, lastResultProps);\n            childProps = lastResultProps;\n          }\n\n          return React.createElement(WrappedComponent, __assign({}, props, childProps));\n        });\n      };\n\n      GraphQL.displayName = graphQLDisplayName;\n      GraphQL.WrappedComponent = WrappedComponent;\n      return GraphQL;\n    }(GraphQLBase);\n\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n\nfunction withMutation(document, operationOptions) {\n  if (operationOptions === void 0) {\n    operationOptions = {};\n  }\n\n  var operation = parser(document);\n  var _a = operationOptions.options,\n      options = _a === void 0 ? defaultMapPropsToOptions : _a,\n      _b = operationOptions.alias,\n      alias = _b === void 0 ? 'Apollo' : _b;\n  var mapPropsToOptions = options;\n  if (typeof mapPropsToOptions !== 'function') mapPropsToOptions = function () {\n    return options;\n  };\n  return function (WrappedComponent) {\n    var graphQLDisplayName = alias + \"(\" + getDisplayName(WrappedComponent) + \")\";\n\n    var GraphQL = function (_super) {\n      __extends(GraphQL, _super);\n\n      function GraphQL() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      GraphQL.prototype.render = function () {\n        var props = this.props;\n        var opts = mapPropsToOptions(props);\n\n        if (operationOptions.withRef) {\n          this.withRef = true;\n          props = Object.assign({}, props, {\n            ref: this.setWrappedInstance\n          });\n        }\n\n        if (!opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(operation, props);\n        }\n\n        return React.createElement(Mutation, __assign({\n          ignoreResults: true\n        }, opts, {\n          mutation: document\n        }), function (mutate, _a) {\n          var _b, _c;\n\n          var data = _a.data,\n              r = __rest(_a, [\"data\"]);\n\n          var result = Object.assign(r, data || {});\n          var name = operationOptions.name || 'mutate';\n          var resultName = operationOptions.name ? name + \"Result\" : 'result';\n          var childProps = (_b = {}, _b[name] = mutate, _b[resultName] = result, _b);\n\n          if (operationOptions.props) {\n            var newResult = (_c = {}, _c[name] = mutate, _c[resultName] = result, _c.ownProps = props, _c);\n            childProps = operationOptions.props(newResult);\n          }\n\n          return React.createElement(WrappedComponent, __assign({}, props, childProps));\n        });\n      };\n\n      GraphQL.displayName = graphQLDisplayName;\n      GraphQL.WrappedComponent = WrappedComponent;\n      return GraphQL;\n    }(GraphQLBase);\n\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n\nfunction withSubscription(document, operationOptions) {\n  if (operationOptions === void 0) {\n    operationOptions = {};\n  }\n\n  var operation = parser(document);\n  var _a = operationOptions.options,\n      options = _a === void 0 ? defaultMapPropsToOptions : _a,\n      _b = operationOptions.skip,\n      skip = _b === void 0 ? defaultMapPropsToSkip : _b,\n      _c = operationOptions.alias,\n      alias = _c === void 0 ? 'Apollo' : _c,\n      shouldResubscribe = operationOptions.shouldResubscribe;\n  var mapPropsToOptions = options;\n  if (typeof mapPropsToOptions !== 'function') mapPropsToOptions = function () {\n    return options;\n  };\n  var mapPropsToSkip = skip;\n  if (typeof mapPropsToSkip !== 'function') mapPropsToSkip = function () {\n    return skip;\n  };\n  var lastResultProps;\n  return function (WrappedComponent) {\n    var graphQLDisplayName = alias + \"(\" + getDisplayName(WrappedComponent) + \")\";\n\n    var GraphQL = function (_super) {\n      __extends(GraphQL, _super);\n\n      function GraphQL(props) {\n        var _this = _super.call(this, props) || this;\n\n        _this.state = {\n          resubscribe: false\n        };\n        return _this;\n      }\n\n      GraphQL.prototype.componentDidUpate = function (prevProps) {\n        if (shouldResubscribe) {\n          this.setState({\n            resubscribe: shouldResubscribe(prevProps, this.props)\n          });\n        }\n      };\n\n      GraphQL.prototype.render = function () {\n        var _this = this;\n\n        var props = this.props;\n        var shouldSkip = mapPropsToSkip(props);\n        var opts = shouldSkip ? Object.create(null) : mapPropsToOptions(props);\n\n        if (!shouldSkip && !opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(operation, props);\n        }\n\n        return React.createElement(Subscription, __assign({}, opts, {\n          displayName: graphQLDisplayName,\n          skip: shouldSkip,\n          subscription: document,\n          shouldResubscribe: this.state.resubscribe\n        }), function (_a) {\n          var _b, _c;\n\n          var data = _a.data,\n              r = __rest(_a, [\"data\"]);\n\n          if (operationOptions.withRef) {\n            _this.withRef = true;\n            props = Object.assign({}, props, {\n              ref: _this.setWrappedInstance\n            });\n          }\n\n          if (shouldSkip) {\n            return React.createElement(WrappedComponent, __assign({}, props, {}));\n          }\n\n          var result = Object.assign(r, data || {});\n          var name = operationOptions.name || 'data';\n          var childProps = (_b = {}, _b[name] = result, _b);\n\n          if (operationOptions.props) {\n            var newResult = (_c = {}, _c[name] = result, _c.ownProps = props, _c);\n            lastResultProps = operationOptions.props(newResult, lastResultProps);\n            childProps = lastResultProps;\n          }\n\n          return React.createElement(WrappedComponent, __assign({}, props, childProps));\n        });\n      };\n\n      GraphQL.displayName = graphQLDisplayName;\n      GraphQL.WrappedComponent = WrappedComponent;\n      return GraphQL;\n    }(GraphQLBase);\n\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n\nfunction graphql(document, operationOptions) {\n  if (operationOptions === void 0) {\n    operationOptions = {};\n  }\n\n  switch (parser(document).type) {\n    case DocumentType.Mutation:\n      return withMutation(document, operationOptions);\n\n    case DocumentType.Subscription:\n      return withSubscription(document, operationOptions);\n\n    case DocumentType.Query:\n    default:\n      return withQuery(document, operationOptions);\n  }\n}\n\nfunction getDisplayName$1(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nfunction withApollo(WrappedComponent, operationOptions) {\n  if (operationOptions === void 0) {\n    operationOptions = {};\n  }\n\n  var withDisplayName = \"withApollo(\" + getDisplayName$1(WrappedComponent) + \")\";\n\n  var WithApollo = function (_super) {\n    __extends(WithApollo, _super);\n\n    function WithApollo(props) {\n      var _this = _super.call(this, props) || this;\n\n      _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);\n      return _this;\n    }\n\n    WithApollo.prototype.getWrappedInstance = function () {\n      process.env.NODE_ENV === \"production\" ? invariant(operationOptions.withRef, 1) : invariant(operationOptions.withRef, \"To access the wrapped instance, you need to specify \" + \"{ withRef: true } in the options\");\n      return this.wrappedInstance;\n    };\n\n    WithApollo.prototype.setWrappedInstance = function (ref) {\n      this.wrappedInstance = ref;\n    };\n\n    WithApollo.prototype.render = function () {\n      var _this = this;\n\n      return React.createElement(ApolloConsumer, null, function (client) {\n        var props = Object.assign({}, _this.props, {\n          client: client,\n          ref: operationOptions.withRef ? _this.setWrappedInstance : undefined\n        });\n        return React.createElement(WrappedComponent, __assign({}, props));\n      });\n    };\n\n    WithApollo.displayName = withDisplayName;\n    WithApollo.WrappedComponent = WrappedComponent;\n    return WithApollo;\n  }(React.Component);\n\n  return hoistNonReactStatics(WithApollo, WrappedComponent, {});\n}\n\nexport { graphql, withApollo, withMutation, withQuery, withSubscription };","map":{"version":3,"mappings":"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","names":["defaultMapPropsToOptions","defaultMapPropsToSkip","getDisplayName","WrappedComponent","displayName","name","calculateVariablesFromProps","operation","props","variables","_i","variable","type","value","variableName","variableProp","kind","undefined","__extends","_super","_this","setWrappedInstance","bind","GraphQLBase","process","wrappedInstance","ref","React","Component","withQuery","document","operationOptions","parser","_b","skip","_c","alias","mapPropsToOptions","options","mapPropsToSkip","lastResultProps","graphQLDisplayName","GraphQL","shouldSkip","opts","Object","create","length","Query","__assign","query","_a","data","r","withRef","assign","result","childProps","newResult","hoistNonReactStatics","withMutation","Mutation","ignoreResults","mutation","mutate","resultName","withSubscription","shouldResubscribe","state","resubscribe","prevProps","setState","Subscription","subscription","graphql","DocumentType","withApollo","withDisplayName","WithApollo","ApolloConsumer","client"],"sources":["/Volumes/Nana/I_T/projects_code/react/node_modules/@apollo/react-hoc/src/hoc-utils.tsx","/Volumes/Nana/I_T/projects_code/react/node_modules/@apollo/react-hoc/src/query-hoc.tsx","/Volumes/Nana/I_T/projects_code/react/node_modules/@apollo/react-hoc/src/mutation-hoc.tsx","/Volumes/Nana/I_T/projects_code/react/node_modules/@apollo/react-hoc/src/subscription-hoc.tsx","/Volumes/Nana/I_T/projects_code/react/node_modules/@apollo/react-hoc/src/graphql.tsx","/Volumes/Nana/I_T/projects_code/react/node_modules/@apollo/react-hoc/src/withApollo.tsx"],"sourcesContent":["import React from 'react';\nimport { invariant } from 'ts-invariant';\nimport { IDocumentDefinition, OperationVariables } from '@apollo/react-common';\n\nexport const defaultMapPropsToOptions = () => ({});\nexport const defaultMapResultToProps: <P>(props: P) => P = props => props;\nexport const defaultMapPropsToSkip = () => false;\n\nexport function getDisplayName<P>(WrappedComponent: React.ComponentType<P>) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nexport function calculateVariablesFromProps<TProps>(\n  operation: IDocumentDefinition,\n  props: TProps\n) {\n  let variables: OperationVariables = {};\n  for (let { variable, type } of operation.variables) {\n    if (!variable.name || !variable.name.value) continue;\n\n    const variableName = variable.name.value;\n    const variableProp = (props as any)[variableName];\n\n    if (typeof variableProp !== 'undefined') {\n      variables[variableName] = variableProp;\n      continue;\n    }\n\n    // Allow optional props\n    if (type.kind !== 'NonNullType') {\n      variables[variableName] = undefined;\n    }\n  }\n  return variables;\n}\n\nexport type RefSetter<TChildProps> = (\n  ref: React.ComponentClass<TChildProps>\n) => void | void;\n\n// base class for hocs to easily manage refs\nexport class GraphQLBase<\n  TProps,\n  TChildProps,\n  TState = any\n  > extends React.Component<TProps, TState> {\n  public withRef: boolean = false;\n  // wrapped instance\n  private wrappedInstance?: React.ComponentClass<TChildProps>;\n\n  constructor(props: TProps) {\n    super(props);\n    this.setWrappedInstance = this.setWrappedInstance.bind(this);\n  }\n\n  getWrappedInstance() {\n    invariant(\n      this.withRef,\n      `To access the wrapped instance, you need to specify ` +\n      `{ withRef: true } in the options`\n    );\n\n    return this.wrappedInstance;\n  }\n\n  setWrappedInstance(ref: React.ComponentClass<TChildProps>) {\n    this.wrappedInstance = ref;\n  }\n}\n","import React from 'react';\nimport { DocumentNode } from 'graphql';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport { parser, BaseQueryOptions } from '@apollo/react-common';\nimport { Query } from '@apollo/react-components';\n\nimport {\n  getDisplayName,\n  GraphQLBase,\n  calculateVariablesFromProps,\n  defaultMapPropsToOptions,\n  defaultMapPropsToSkip\n} from './hoc-utils';\nimport { OperationOption, OptionProps, DataProps } from './types';\n\nexport function withQuery<\n  TProps extends TGraphQLVariables | {} = {},\n  TData = {},\n  TGraphQLVariables = {},\n  TChildProps = DataProps<TData, TGraphQLVariables>\n>(\n  document: DocumentNode,\n  operationOptions: OperationOption<\n    TProps,\n    TData,\n    TGraphQLVariables,\n    TChildProps\n  > = {}\n) {\n  // this is memoized so if coming from `graphql` there is nearly no extra cost\n  const operation = parser(document);\n  // extract options\n  const {\n    options = defaultMapPropsToOptions,\n    skip = defaultMapPropsToSkip,\n    alias = 'Apollo'\n  } = operationOptions;\n\n  let mapPropsToOptions = options as (props: any) => BaseQueryOptions;\n  if (typeof mapPropsToOptions !== 'function') {\n    mapPropsToOptions = () => options as BaseQueryOptions;\n  }\n\n  let mapPropsToSkip = skip as (props: any) => boolean;\n  if (typeof mapPropsToSkip !== 'function') {\n    mapPropsToSkip = () => skip as any;\n  }\n\n  // allow for advanced referential equality checks\n  let lastResultProps: TChildProps | void;\n  return (\n    WrappedComponent: React.ComponentType<TProps & TChildProps>\n  ): React.ComponentClass<TProps> => {\n    const graphQLDisplayName = `${alias}(${getDisplayName(WrappedComponent)})`;\n    class GraphQL extends GraphQLBase<TProps, TChildProps> {\n      static displayName = graphQLDisplayName;\n      static WrappedComponent = WrappedComponent;\n\n      render() {\n        let props = this.props;\n        const shouldSkip = mapPropsToSkip(props);\n        const opts = shouldSkip\n          ? Object.create(null)\n          : { ...mapPropsToOptions(props) };\n\n        if (!shouldSkip && !opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(operation, props);\n        }\n\n        return (\n          <Query\n            {...opts}\n            displayName={graphQLDisplayName}\n            skip={shouldSkip}\n            query={document}\n          >\n            {({ client: _, data, ...r }: any) => {\n              if (operationOptions.withRef) {\n                this.withRef = true;\n                props = Object.assign({}, props, {\n                  ref: this.setWrappedInstance\n                });\n              }\n\n              // if we have skipped, no reason to manage any reshaping\n              if (shouldSkip) {\n                return (\n                  <WrappedComponent\n                    {...props as TProps}\n                    {...{} as TChildProps}\n                  />\n                );\n              }\n\n              // the HOC's historically hoisted the data from the execution result\n              // up onto the result since it was passed as a nested prop\n              // we massage the Query components shape here to replicate that\n              const result = Object.assign(r, data || {});\n              const name = operationOptions.name || 'data';\n              let childProps = { [name]: result };\n              if (operationOptions.props) {\n                const newResult: OptionProps<\n                  TProps,\n                  TData,\n                  TGraphQLVariables\n                > = {\n                  [name]: result,\n                  ownProps: props as TProps\n                };\n                lastResultProps = operationOptions.props(\n                  newResult,\n                  lastResultProps\n                );\n                childProps = lastResultProps;\n              }\n\n              return (\n                <WrappedComponent\n                  {...props as TProps}\n                  {...childProps as TChildProps}\n                />\n              );\n            }}\n          </Query>\n        );\n      }\n    }\n\n    // Make sure we preserve any custom statics on the original component.\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n","import React from 'react';\nimport { DocumentNode } from 'graphql';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport {\n  parser,\n  BaseMutationOptions,\n  MutationFunction,\n  MutationResult\n} from '@apollo/react-common';\nimport { Mutation } from '@apollo/react-components';\n\nimport {\n  defaultMapPropsToOptions,\n  getDisplayName,\n  calculateVariablesFromProps,\n  GraphQLBase\n} from './hoc-utils';\nimport { OperationOption, OptionProps, MutateProps } from './types';\n\nexport function withMutation<\n  TProps extends TGraphQLVariables | {} = {},\n  TData = {},\n  TGraphQLVariables = {},\n  TChildProps = MutateProps<TData, TGraphQLVariables>\n>(\n  document: DocumentNode,\n  operationOptions: OperationOption<\n    TProps,\n    TData,\n    TGraphQLVariables,\n    TChildProps\n  > = {}\n) {\n  // this is memoized so if coming from `graphql` there is nearly no extra cost\n  const operation = parser(document);\n  // extract options\n\n  const {\n    options = defaultMapPropsToOptions,\n    alias = 'Apollo'\n  } = operationOptions;\n\n  let mapPropsToOptions = options as (props: any) => BaseMutationOptions;\n  if (typeof mapPropsToOptions !== 'function')\n    mapPropsToOptions = () => options as BaseMutationOptions;\n\n  return (\n    WrappedComponent: React.ComponentType<TProps & TChildProps>\n  ): React.ComponentClass<TProps> => {\n    const graphQLDisplayName = `${alias}(${getDisplayName(WrappedComponent)})`;\n    class GraphQL extends GraphQLBase<TProps, TChildProps> {\n      static displayName = graphQLDisplayName;\n      static WrappedComponent = WrappedComponent;\n      render() {\n        let props = this.props as TProps;\n        const opts = mapPropsToOptions(props);\n\n        if (operationOptions.withRef) {\n          this.withRef = true;\n          props = Object.assign({}, props, {\n            ref: this.setWrappedInstance\n          });\n        }\n        if (!opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(operation, props);\n        }\n\n        return (\n          <Mutation ignoreResults {...opts} mutation={document}>\n            {(\n              mutate: MutationFunction<TData, TGraphQLVariables>,\n              { data, ...r }: MutationResult<TData>\n            ) => {\n              // the HOC's historically hoisted the data from the execution result\n              // up onto the result since it was passed as a nested prop\n              // we massage the Mutation component's shape here to replicate that\n              // this matches the query HoC\n              const result = Object.assign(r, data || {});\n              const name = operationOptions.name || 'mutate';\n              const resultName = operationOptions.name\n                ? `${name}Result`\n                : 'result';\n              let childProps = ({\n                [name]: mutate,\n                [resultName]: result\n              } as any) as TChildProps;\n              if (operationOptions.props) {\n                const newResult: OptionProps<\n                  TProps,\n                  TData,\n                  TGraphQLVariables\n                > = {\n                  [name]: mutate,\n                  [resultName]: result,\n                  ownProps: props\n                };\n                childProps = operationOptions.props(newResult) as any;\n              }\n\n              return <WrappedComponent {...props} {...childProps} />;\n            }}\n          </Mutation>\n        );\n      }\n    }\n\n    // Make sure we preserve any custom statics on the original component.\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n","import React from 'react';\nimport { DocumentNode } from 'graphql';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport { parser, BaseQueryOptions } from '@apollo/react-common';\nimport { Subscription } from '@apollo/react-components';\n\nimport {\n  getDisplayName,\n  GraphQLBase,\n  calculateVariablesFromProps,\n  defaultMapPropsToOptions,\n  defaultMapPropsToSkip\n} from './hoc-utils';\nimport { OperationOption, OptionProps, DataProps } from './types';\n\nexport function withSubscription<\n  TProps extends TGraphQLVariables | {} = {},\n  TData = {},\n  TGraphQLVariables = {},\n  TChildProps = DataProps<TData, TGraphQLVariables>\n>(\n  document: DocumentNode,\n  operationOptions: OperationOption<\n    TProps,\n    TData,\n    TGraphQLVariables,\n    TChildProps\n  > = {}\n) {\n  // this is memoized so if coming from `graphql` there is nearly no extra cost\n  const operation = parser(document);\n  // extract options\n  const {\n    options = defaultMapPropsToOptions,\n    skip = defaultMapPropsToSkip,\n    alias = 'Apollo',\n    shouldResubscribe\n  } = operationOptions;\n\n  let mapPropsToOptions = options as (props: any) => BaseQueryOptions;\n  if (typeof mapPropsToOptions !== 'function')\n    mapPropsToOptions = () => options as BaseQueryOptions;\n\n  let mapPropsToSkip = skip as (props: any) => boolean;\n  if (typeof mapPropsToSkip !== 'function') mapPropsToSkip = () => skip as any;\n\n  // allow for advanced referential equality checks\n  let lastResultProps: TChildProps | void;\n  return (\n    WrappedComponent: React.ComponentType<TProps & TChildProps>\n  ): React.ComponentClass<TProps> => {\n    const graphQLDisplayName = `${alias}(${getDisplayName(WrappedComponent)})`;\n    class GraphQL extends GraphQLBase<\n      TProps,\n      TChildProps,\n      { resubscribe: boolean }\n    > {\n      static displayName = graphQLDisplayName;\n      static WrappedComponent = WrappedComponent;\n      constructor(props: TProps) {\n        super(props);\n        this.state = { resubscribe: false };\n      }\n\n      componentDidUpate(prevProps: TProps) {\n        if (shouldResubscribe) {\n          this.setState({\n            resubscribe: shouldResubscribe(prevProps, this.props)\n          });\n        }\n      }\n\n      render() {\n        let props = this.props;\n        const shouldSkip = mapPropsToSkip(props);\n        const opts = shouldSkip\n          ? Object.create(null)\n          : mapPropsToOptions(props);\n\n        if (!shouldSkip && !opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(operation, props);\n        }\n        return (\n          <Subscription\n            {...opts}\n            displayName={graphQLDisplayName}\n            skip={shouldSkip}\n            subscription={document}\n            shouldResubscribe={this.state.resubscribe}\n          >\n            {({ data, ...r }: any) => {\n              if (operationOptions.withRef) {\n                this.withRef = true;\n                props = Object.assign({}, props, {\n                  ref: this.setWrappedInstance\n                });\n              }\n              // if we have skipped, no reason to manage any reshaping\n              if (shouldSkip) {\n                return (\n                  <WrappedComponent\n                    {...props as TProps}\n                    {...{} as TChildProps}\n                  />\n                );\n              }\n\n              // the HOC's historically hoisted the data from the execution result\n              // up onto the result since it was passed as a nested prop\n              // we massage the Query components shape here to replicate that\n              const result = Object.assign(r, data || {});\n              const name = operationOptions.name || 'data';\n              let childProps = { [name]: result };\n              if (operationOptions.props) {\n                const newResult: OptionProps<\n                  TProps,\n                  TData,\n                  TGraphQLVariables\n                > = {\n                  [name]: result,\n                  ownProps: props as TProps\n                };\n                lastResultProps = operationOptions.props(\n                  newResult,\n                  lastResultProps\n                );\n                childProps = lastResultProps;\n              }\n\n              return (\n                <WrappedComponent\n                  {...props as TProps}\n                  {...childProps as TChildProps}\n                />\n              );\n            }}\n          </Subscription>\n        );\n      }\n    }\n\n    // Make sure we preserve any custom statics on the original component.\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n","import { DocumentNode } from 'graphql';\nimport { parser, DocumentType } from '@apollo/react-common';\n\nimport { withQuery } from './query-hoc';\nimport { withMutation } from './mutation-hoc';\nimport { withSubscription } from './subscription-hoc';\nimport { OperationOption, DataProps, MutateProps } from './types';\n\nexport function graphql<\n  TProps extends TGraphQLVariables | {} = {},\n  TData = {},\n  TGraphQLVariables = {},\n  TChildProps = Partial<DataProps<TData, TGraphQLVariables>> &\n    Partial<MutateProps<TData, TGraphQLVariables>>\n>(\n  document: DocumentNode,\n  operationOptions: OperationOption<\n    TProps,\n    TData,\n    TGraphQLVariables,\n    TChildProps\n  > = {}\n) {\n  switch (parser(document).type) {\n    case DocumentType.Mutation:\n      return withMutation(document, operationOptions);\n    case DocumentType.Subscription:\n      return withSubscription(document, operationOptions);\n    case DocumentType.Query:\n    default:\n      return withQuery(document, operationOptions);\n  }\n}\n","import React from 'react';\nimport { ApolloConsumer } from '@apollo/react-common';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport { invariant } from 'ts-invariant';\n\nimport { OperationOption, WithApolloClient } from './types';\n\nfunction getDisplayName<P>(WrappedComponent: React.ComponentType<P>) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nexport function withApollo<TProps, TResult = any>(\n  WrappedComponent: React.ComponentType<\n    WithApolloClient<Omit<TProps, 'client'>>\n  >,\n  operationOptions: OperationOption<TProps, TResult> = {}\n): React.ComponentClass<Omit<TProps, 'client'>> {\n  const withDisplayName = `withApollo(${getDisplayName(WrappedComponent)})`;\n\n  class WithApollo extends React.Component<Omit<TProps, 'client'>> {\n    static displayName = withDisplayName;\n    static WrappedComponent = WrappedComponent;\n\n    // wrapped instance\n    private wrappedInstance: any;\n\n    constructor(props: Omit<TProps, 'client'>) {\n      super(props);\n      this.setWrappedInstance = this.setWrappedInstance.bind(this);\n    }\n\n    getWrappedInstance() {\n      invariant(\n        operationOptions.withRef,\n        `To access the wrapped instance, you need to specify ` +\n          `{ withRef: true } in the options`\n      );\n\n      return this.wrappedInstance;\n    }\n\n    setWrappedInstance(ref: React.ComponentType<WithApolloClient<TProps>>) {\n      this.wrappedInstance = ref;\n    }\n\n    render() {\n      return (\n        <ApolloConsumer>\n          {client => {\n            const props = Object.assign({}, this.props, {\n              client,\n              ref: operationOptions.withRef\n                ? this.setWrappedInstance\n                : undefined\n            });\n            return <WrappedComponent {...props} />;\n          }}\n        </ApolloConsumer>\n      );\n    }\n  }\n\n  // Make sure we preserve any custom statics on the original component.\n  return hoistNonReactStatics(WithApollo, WrappedComponent, {});\n}\n"]},"metadata":{},"sourceType":"module"}